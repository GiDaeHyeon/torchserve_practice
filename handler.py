import osimport torchimport torch.nn.functional as Ffrom torchvision import transforms as Tfrom ts.torch_handler.base_handler import BaseHandlerimport ioimport base64from PIL import Imagefrom io import BytesIOclass PracticeHandler(BaseHandler):    def __init__(self):        super(PracticeHandler, self).__init__()        self.transform = T.Compose([            T.Resize(256),            T.CenterCrop(224),            T.ToTensor(),            T.Normalize(mean=[.485, .456, .406],                        std=[.229, .224, .225])        ])    def initialize(self, context):        #  load the model        self.manifest = context.manifest        properties = context.system_properties        model_dir = properties.get("model_dir")        self.device = torch.device("cuda:" + str(properties.get("gpu_id")) if torch.cuda.is_available() else "cpu")        # Read model serialize/pt file        serialized_file = self.manifest['model']['serializedFile']        model_pt_path = os.path.join(model_dir, serialized_file)        if not os.path.isfile(model_pt_path):            raise RuntimeError("Missing the model.pt file")        self.model = torch.jit.load(model_pt_path)        self.initialized = True    def preprocess_one_image(self, data):        image = data.get('data')        if image is None:            image = data.get('body')        img_bytes = base64.b64decode(bytes(image))        image_pil = Image.open(BytesIO(img_bytes))        image = self.transform(image_pil)        image = image.unsqueeze(0)        return image    def preprocess(self, data):        images = [self.preprocess_one_image(req) for req in data]        images = torch.cat(images)        return images    def inference(self, data, *args, **kwargs):        outs = self.model.forward(data)        y_hat = F.softmax(outs, dim=1)        preds = torch.argmax(y_hat, dim=1)        return preds    def postprocess(self, data):        res = []        preds = data.cpu().tolist()        for pred in preds:            res.append({'index': pred})        return res    def handle(self, data, context):        if not self.initialized:            self.initialize(context)        if data is None:            return None        data = self.preprocess(data)        data = self.inference(data)        data = self.postprocess(data)        return data